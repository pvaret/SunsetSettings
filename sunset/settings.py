from typing import (
    Iterator,
    MutableSet,
    Optional,
    Sequence,
    TextIO,
    TypeVar,
)

from .bundle import Bundle
from .exporter import normalize, loadFromFile, saveToFile
from .non_hashable_set import NonHashableSet
from .protocols import UpdateNotifier

_MAIN = "main"


# TODO: Replace with typing.Self when mypy finally supports that.
Self = TypeVar("Self", bound="Settings")


class Settings(Bundle):
    """
    A collection of keys that can be saved to and loaded from text, and supports
    subsections.

    Under the hood, a Settings class is a dataclass, and can be used in the same
    manner, i.e. by defining attributes directly on the class itself.

    Settings instances support subsections: calling the :meth:`newSection()`
    method on an instance creates a subsection of that instance. This subsection
    holds the same keys, with independant values. If a key of the subsection
    does not have a value, its value will be looked up on its parent section
    instead. The hierarchy of sections can be arbitrarily deep.

    When saving a Settings instance, its subsections are saved with it under a
    distinct heading for each, provided they have a name. A section is given a
    name by passing it to the :meth:`newSection()` method, or by using the
    :meth:`setSectionName()` method on the new section after creation.

    Anonymous (unnamed) sections do not get saved. The name of each section is
    used to construct the heading it is saved under. The top-level Settings
    instance is saved under the '[main]' heading.

    Example:

    >>> from sunset import Key, Settings
    >>> class AnimalSettings(Settings):
    ...     hearts = Key(default=0)
    ...     legs = Key(default=0)
    ...     wings = Key(default=0)
    ...     fur = Key(default=False)
    >>> animals = AnimalSettings()
    >>> animals.hearts.set(1)
    >>> mammals = animals.newSection(name="mammals")
    >>> mammals.fur.set(True)
    >>> mammals.legs.set(4)
    >>> humans = mammals.newSection(name="humans")
    >>> humans.legs.set(2)
    >>> humans.fur.set(False)
    >>> birds = animals.newSection(name="birds")
    >>> birds.legs.set(2)
    >>> birds.wings.set(2)
    >>> aliens = animals.newSection()  # No name given!
    >>> aliens.hearts.set(2)
    >>> aliens.legs.set(7)
    >>> print(mammals.hearts.get())
    1
    >>> print(mammals.legs.get())
    4
    >>> print(mammals.wings.get())
    0
    >>> print(mammals.fur.get())
    True
    >>> print(birds.hearts.get())
    1
    >>> print(birds.legs.get())
    2
    >>> print(birds.wings.get())
    2
    >>> print(birds.fur.get())
    False
    >>> print(humans.hearts.get())
    1
    >>> print(humans.legs.get())
    2
    >>> print(humans.wings.get())
    0
    >>> print(humans.fur.get())
    False
    >>> print(aliens.hearts.get())
    2
    >>> print(aliens.legs.get())
    7
    >>> print(aliens.wings.get())
    0
    >>> print(aliens.fur.get())
    False
    >>> import io
    >>> txt = io.StringIO()
    >>> animals.save(txt)
    >>> print(txt.getvalue(), end="")
    [main]
    hearts = 1
    [birds]
    legs = 2
    wings = 2
    [mammals]
    fur = true
    legs = 4
    [mammals/humans]
    fur = false
    legs = 2
    """

    MAIN: str = _MAIN

    _section_name: str
    _children: MutableSet[Bundle]

    def __post_init__(self) -> None:

        super().__post_init__()

        self._section_name = ""

        # Note that this overrides the similarly named attribute from the parent
        # class. In the parent class, the set does not keep references to its
        # items; in this class, it does.

        self._children = NonHashableSet()

    def newSection(self: Self, name: Optional[str] = None) -> Self:
        """
        Creates and returns a new instance of this class. Each key of the new
        instance will inherit from the key of the same name on the parent
        instance.

        When saving Settings with the :meth:`save()` method, each section's name
        is used to generate the heading under which that section is saved. If
        the new section is created without a name, it will be skipped when
        saving. A name can still be given to a section after creation with the
        :meth:`setSectionName()` method.

        If this Settings instance already has a section with the given name, the
        new section will be created with a unique name generated by appending a
        numbered suffix to that name.

        Args:
            name: The name that will be used to generate a heading for this
                section when saving it to text. The given name will be
                normalized to lowercase alphanumeric characters.

        Returns:
            An instance of the same type as self.
        """

        new = self.newInstance()
        new.setParent(self)

        if name:

            # Note that this will trigger an update notification.

            new.setSectionName(name)

        return new

    def getOrCreateSection(self: Self, name: str) -> Self:
        """
        Finds and returns the section of these Settings with the given name if
        it exists, and creates it if it doesn't.

        If the given name is empty, this is equivalent to calling
        :meth:`newSection()` instead.

        Args:
            name: The name that will be used to generate a heading for this
                section when saving it to text. The given name will be
                normalized to lowercase alphanumeric characters.

        Returns:
            An instance of the same type as self.
        """

        return (
            section
            if (section := self.getSection(name)) is not None
            else self.newSection(name=name)
        )

    def getSection(self: Self, name: str) -> Optional[Self]:
        """
        Finds and returns a section of this instance with the given name, if it
        exists, else None.

        Args:
            name: The name of the section to return.

        Returns:
            An instance of the same type as self, or None.
        """

        norm = normalize(name)
        if not norm:
            return None

        for section in self.sections():
            if norm == section.sectionName():
                return section

        return None

    def sections(self: Self) -> Iterator[Self]:
        """
        Returns an iterator over the subsections of this Settings instance. Note
        that the subsections are only looked up one level deep, that is to say,
        no recursing into the section hierarchy occurs.

        Returns:
            An iterator over Settings instances of the same type as this one.
        """

        yield from self.children()

    def setSectionName(self, name: str) -> str:
        """
        Sets the unique name under which this Settings instance will be
        persisted by the :meth:`save()` method. The given name will be
        normalized to lowercase, without space or punctuation.

        This name is guaranteed to be unique. If the given name is already used
        by a Settings instance with the same parent as this one, then a numbered
        suffix is generated to make this one's name unique.

        If the given name is empty, these settings will be skipped when saving.

        The toplevel Settings instance is named "main" by default. It cannot be
        unnamed; it will revert to its default name instead.

        Args:
            name: The name that will be used to generate a heading for these
                settings when saving them to text.

        Returns:
            The given name, normalized, and made unique if needed.

        Example:

        >>> from sunset import Settings
        >>> class TestSettings(Settings):
        ...     pass
        >>> parent = TestSettings()
        >>> section1 = parent.newSection()
        >>> section2 = parent.newSection()
        >>> section3 = parent.newSection()
        >>> section1.setSectionName("  T ' e ? S / t")
        'test'
        >>> section2.setSectionName("TEST")
        'test_1'
        >>> section3.setSectionName("test")
        'test_2'
        >>> # This should not change this section's name.
        >>> section3.setSectionName("test")
        'test_2'
        """

        name = name_base = normalize(name)
        previous_name = self.sectionName()

        # Loop until we find an unused name.

        if name:
            i = 0
            while any(
                section.sectionName() == name for section in self.siblings()
            ):
                i += 1
                name = f"{name_base}_{i}"

        self._section_name = name

        if self.sectionName() != previous_name:
            self.triggerUpdateNotification(self)

        return self.sectionName()

    def sectionName(self) -> str:
        """
        Returns the current name of this Settings instance. This name will be
        used to generate the heading under which this Settings instance will be
        persisted by the :meth:`save()` method.

        Returns:
            The name of this Settings instance.
        """
        if self._section_name:
            return self._section_name

        return self._section_name if self.parent() is not None else self.MAIN

    def siblings(self: Self) -> Iterator[Self]:
        """
        Returns an iterator on the sibling sections of this Settings instance,
        that is to say, the subsections of its parent, if any, that aren't this
        section itself.

        Returns:
            An iterator over Settings instances of the same type as this one.
        """

        parent = self.parent()
        if parent is not None:
            yield from (
                section for section in parent.sections() if section is not self
            )

    def hierarchy(self) -> list[str]:
        """
        Internal.
        """

        if not self.sectionName():
            return []

        parent = self.parent()
        if parent is not None and not parent.hierarchy():
            return []

        return (parent.hierarchy() if parent is not None else []) + [
            self.sectionName()
        ]

    def triggerUpdateNotification(
        self, field: Optional[UpdateNotifier]
    ) -> None:

        if not self._update_notification_enabled:
            return

        if field is None:
            field = self

        super().triggerUpdateNotification(field)

        # Note that we always propagate notifications when the concerned field
        # is self. This allows section name changes to be propagated even if the
        # new name is no longer public -- the parent sections may be interested
        # about that name change!

        if (parent := self.parent()) is not None:
            if not self.isPrivate() or field is self:
                parent.triggerUpdateNotification(field)

    def isPrivate(self) -> bool:

        return self.sectionName() == ""

    def dumpAll(
        self,
    ) -> Sequence[tuple[Sequence[str], Sequence[tuple[str, str]]]]:
        """
        Internal.
        """

        hierarchy = self.hierarchy()
        if not hierarchy:

            # This is an anonymous structure, don't dump it.

            return []

        ret: list[tuple[Sequence[str], Sequence[tuple[str, str]]]] = []
        ret.append((hierarchy, self.dump()))

        sections = list(self.sections())
        sections.sort(key=lambda section: section.sectionName())
        for section in sections:
            for hierarchy, dump in section.dumpAll():
                ret.append((hierarchy, dump))

        return ret

    def restoreAll(
        self,
        data: Sequence[tuple[Sequence[str], Sequence[tuple[str, str]]]],
    ) -> None:
        """
        Internal.
        """

        notification_enabled = self._update_notification_enabled
        self._update_notification_enabled = False

        own_sections: dict[str, Settings] = {}
        own_sections_data: list[
            tuple[Sequence[str], Sequence[tuple[str, str]]]
        ] = []

        for hierarchy, dump in data:

            hierarchy = list(map(normalize, hierarchy))
            if not hierarchy:
                continue

            if not hierarchy[0]:
                continue

            if hierarchy[0] != self.sectionName():
                continue

            if len(hierarchy) == 1:

                # This dump applies specifically to this instance.

                self.restore(dump)

            else:
                section_name = normalize(hierarchy[1])
                if not section_name:
                    continue

                if section_name not in own_sections:
                    own_sections[section_name] = self.getOrCreateSection(
                        section_name
                    )
                own_sections_data.append((hierarchy[1:], dump))

        for section in own_sections.values():
            section.restoreAll(own_sections_data)

        self._update_notification_enabled = notification_enabled

    def save(self, file: TextIO, blanklines: bool = False) -> None:
        """
        Writes the contents of this Settings instance and its subsections in
        text form to the given file object.

        Args:
            file: A text file object where to save this Settings instance.
            blanklines: Whether to add a blank line before section headings.

        Returns:
            None.
        """

        if not self.sectionName():

            # This is an anonymous instance, actually. There is therefore
            # nothing to save.

            return

        saveToFile(
            file, self.dumpAll(), self.sectionName(), blanklines=blanklines
        )

    def load(self, file: TextIO) -> None:
        """
        Loads settings from the given text file object.

        If the given file contains lines that don't make sense -- for instance,
        if the line is garbage, or refers to a key that does not exist in this
        Settings class, or it exists but with an incompatible type -- then the
        faulty line is skipped silently.

        If the text file object contains multiple headings, those headings will
        be used to create subsections with the corresponding names.

        Loading settings from a file does not reset the existing settings or
        sections. Which means you can split your configuration into multiple
        files if needed and load each file in turn to reconstruct the full
        settings.

        Args:
            file: A text file open in reading mode.

        Returns:
            None.
        """

        data = loadFromFile(file, self.sectionName())
        self.restoreAll(data)
